# configs/blank_config.yaml
# Drives BOTH simulation and analysis.
# This config is left blank for reference use only.

io:
  results_dir:    # Path|str: where per-N run folders are created
  analysis_subdir:    # str: analysis outputs subdirectory under results_dir

sim:
  n_players_list:    # list[int]: table sizes to simulate
  num_shuffles:    # int: default shuffle count per table size
  seed:    # int: primary RNG seed (results_dir uses seed suffix)
  seed_pair:    # tuple[int,int]|None: two-seed orchestration pair; seed still drives suffixing
  expanded_metrics:    # bool: write expanded metrics parquet
  row_dir:    # Path|str|None: relative folder for row dumps; blank skips write
  per_n:    # dict[int, SimConfig]: per-table overrides mirroring sim options
  power_method:    # str: 'bh' or 'bonferroni' for scheduling strategy
  recompute_num_shuffles:    # bool: derive per-N shuffles from power design
  power_design:
    power:    # float: target statistical power
    control:    # float: FDR q (BH) or alpha (Bonferroni)
    detectable_lift:    # float: minimum absolute lift to detect
    baseline_rate:    # float: assumed baseline win rate
    tail:    # str: 'one_sided' or 'two_sided'
    full_pairwise:    # bool: compare all pairs vs top-1
    endpoint:    # str: 'pairwise' or 'top1'
    min_games_floor:    # int: minimum scheduled games
    max_games_cap:    # int|None: optional cap on games
    use_BY:    # bool: enable Benjamini-Yekutieli correction for BH
    bh_target_rank:    # int|None: target BH order statistic i*
    bh_target_frac:    # float|None: target discovery fraction for BH
  n_jobs:    # int|None: parallel workers for simulation
  desired_sec_per_chunk:    # int: target seconds per work chunk
  ckpt_every_sec:    # int: checkpoint interval in seconds
  score_thresholds:    # list[int]|None: custom threshold grid for scoring
  dice_thresholds:    # list[int]|None: custom dice thresholds
  smart_five_opts:    # sequence[bool]|None: toggle smart five behavior
  smart_one_opts:    # sequence[bool]|None: toggle smart one behavior
  consider_score_opts:    # sequence[bool]: include score-based branching
  consider_dice_opts:    # sequence[bool]: include dice-count branching
  auto_hot_dice_opts:    # sequence[bool]: auto roll on hot dice
  run_up_score_opts:    # sequence[bool]: allow run-up scoring strategy
  include_stop_at:    # bool: append stop_at_{350,400,450,500} variants
  include_stop_at_heuristic:    # bool: append heuristic stop-at variants

analysis:
  run_trueskill:    # bool: compute TrueSkill ratings
  run_head2head:    # bool: execute head-to-head analysis
  run_hgb:    # bool: train histogram gradient boosting model
  n_jobs:    # int: parallel workers for analysis
  log_level:    # str: logger level during analysis
  results_glob:    # str: glob selecting per-N result folders
  outputs:
    curated_rows_name:    # str: curated rows filename
    metrics_name:    # str: metrics parquet filename
    manifest_name:    # str: manifest jsonl filename

ingest:
  row_group_size:    # int: parquet row-group size
  parquet_codec:    # str: parquet compression codec
  batch_rows:    # int: rows processed per batch
  n_jobs:    # int: concurrent ingest workers

combine:
  max_players:    # int: maximum table size to combine

metrics:
  seat_range:    # list[int] or tuple[int,int]: seat indices included in metrics

trueskill:
  beta:    # float: performance variability parameter
  tau:    # float: dynamics factor between runs
  draw_probability:    # float: draw probability
  pooled_weights_by_k:    # dict[int, float]|None: optional weights per player count for pooling

head2head:
  n_jobs:    # int: parallel workers for head-to-head stage
  games_per_pair:    # int: baseline games scheduled per pair
  fdr_q:    # float: FDR control threshold for BH
  bonferroni_total_games_safeguard:    # int|None: skip Bonferroni H2H when estimated total games exceed this
  bonferroni_design:
    power:    # float: target statistical power
    control:    # float: family-wise error rate (alpha)
    detectable_lift:    # float: minimum lift considered meaningful
    baseline_rate:    # float: assumed baseline win rate
    full_pairwise:    # bool: compare all pairs vs top-1
    tail:    # str: 'one_sided' or 'two_sided'
    min_games_floor:    # int: minimum games per comparison
    max_games_cap:    # int|None: cap on games per comparison
    use_BY:    # bool|None: optional Benjamini-Yekutieli toggle
  tie_break_policy:    # str: 'neutral_edge' (default) or 'simulate_game'
  tie_break_seed:    # int|None: overrides sim.seed for tie-break RNG

hgb:
  max_depth:    # int: maximum tree depth
  n_estimators:    # int: boosting iterations
